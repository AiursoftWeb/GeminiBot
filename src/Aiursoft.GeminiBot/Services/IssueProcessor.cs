using Aiursoft.GeminiBot.Models;
using Aiursoft.NugetNinja.GitServerBase.Models;
using Aiursoft.NugetNinja.GitServerBase.Services;
using Aiursoft.NugetNinja.GitServerBase.Services.Providers;
using Microsoft.Extensions.Logging;

namespace Aiursoft.GeminiBot.Services;

/// <summary>
/// Encapsulates the business logic for processing GitLab issues.
/// </summary>
public class IssueProcessor
{
    private readonly IVersionControlService _versionControl;
    private readonly BotWorkflowEngine _workflowEngine;
    private readonly HttpWrapper _httpWrapper;
    private readonly ILogger<IssueProcessor> _logger;

    public IssueProcessor(
        IVersionControlService versionControl,
        BotWorkflowEngine workflowEngine,
        HttpWrapper httpWrapper,
        ILogger<IssueProcessor> logger)
    {
        _versionControl = versionControl;
        _workflowEngine = workflowEngine;
        _httpWrapper = httpWrapper;
        _logger = logger;
    }

    public async Task<ProcessResult> ProcessAsync(Issue issue, Server server)
    {
        try
        {
            ValidateIssue(issue);
            _logger.LogInformation("Analyzing Issue #{IssueId}: {Title} on {EndPoint} (Project ID: {ProjectId})...", 
                issue.Iid, issue.Title, server.EndPoint, issue.ProjectId);
            
            // Fetch repository details as early as possible for better logging and context.
            var repository = await _versionControl.GetRepository(
                server.EndPoint,
                issue.ProjectId.ToString(),
                string.Empty,
                server.Token);

            _logger.LogInformation("Working on repository: {RepoName} ({RepoUrl})", 
                repository.Name, repository.CloneUrl);

            if (await _versionControl.HasOpenPullRequestForIssue(server.EndPoint, issue.ProjectId, issue.Iid, server.Token))
            {
                _logger.LogInformation("Issue #{IssueId} already has an open PR/MR. Skipping to avoid duplicate work.", issue.Iid);
                return ProcessResult.Skipped("Issue already has an open PR/MR");
            }

            if (!await IsIssueOpenAsync(server, issue))
            {
                _logger.LogInformation("Issue #{IssueId} is already closed. Skipping.", issue.Iid);
                return ProcessResult.Skipped("Issue is already closed");
            }

            _logger.LogInformation("Issue #{IssueId} needs attention. Bot will create a fork and a new MR.", issue.Iid);
            
            var defaultBranch = repository.DefaultBranch ?? "master"; // Fallback to master if null

            var context = new WorkflowContext
            {
                Server = server,
                ProjectId = issue.ProjectId.ToString(),
                SourceBranch = defaultBranch, // Use repository's default branch
                TargetBranch = defaultBranch,
                WorkspaceName = $"issue-{issue.Iid}",
                Prompt = BuildTaskDescription(issue),
                CommitMessage = $"Fix for issue #{issue.Iid}: {issue.Title}\n\nAutomatically generated by Gemini Bot.",
                PushBranch = $"fix-issue-{issue.Iid}",
                HideGitFolder = true
            };

            await _workflowEngine.ExecuteAsync(context, async ctx =>
            {
                await _workflowEngine.EnsureRepositoryForkedAsync(server, ctx.Repository!);
                var pushPath = _versionControl.GetPushPath(server, ctx.Repository!);
                await _workflowEngine.PushAndFinalizeAsync(ctx, pushPath);

                if (await IsIssueOpenAsync(server, issue))
                {
                    await CreatePullRequestIfNeededAsync(server, ctx.Repository!, issue, ctx.PushBranch);
                }
                else
                {
                    _logger.LogWarning("Issue #{IssueId} has been closed while processing. Skipping pull request creation.", issue.Iid);
                }
            });

            return context.Result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing issue #{IssueIid}", issue.Iid);
            return ProcessResult.Failed($"Error processing issue #{issue.Iid}", ex);
        }
    }

    private async Task<bool> IsIssueOpenAsync(Server server, Issue issue)
    {
        if (server.Provider != "GitLab")
        {
            // For other providers, we don't have a direct way to check yet via IVersionControlService.
            // We assume it's still open to avoid breaking existing functionality for other providers.
            return true;
        }

        try
        {
            var url = $"{server.EndPoint.TrimEnd('/')}/api/v4/projects/{issue.ProjectId}/issues/{issue.Iid}";
            var issueDetails = await _httpWrapper.SendHttpAndGetJson<GitLabIssueDto>(url, HttpMethod.Get, server.Token);
            return string.Equals(issueDetails.State, "opened", StringComparison.OrdinalIgnoreCase);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to check if issue #{IssueId} is still open. Assuming it is.", issue.Iid);
            return true;
        }
    }

    private void ValidateIssue(Issue issue)
    {
        if (string.IsNullOrWhiteSpace(issue.Title))
            throw new ArgumentException($"Issue {issue.Id} has no title", nameof(issue));
        if (issue.ProjectId <= 0)
            throw new ArgumentException($"Issue {issue.Id} has invalid project ID", nameof(issue));
    }

    private string BuildTaskDescription(Issue issue)
    {
        return $"Issue #{issue.Iid}: {issue.Title}\n\n{issue.Description ?? "No description provided."}\n\nPlease analyze this issue and make the necessary code changes to resolve it.\n\nDon't forget to bump the version for updated nuget package projects after necessary changes, while do NOT add a version tag for projects doesn't publish nuget packages!";
    }

    private async Task CreatePullRequestIfNeededAsync(Server server, Repository repository, Issue issue, string branchName)
    {
        var ownerLogin = repository.Owner?.Login ?? throw new InvalidOperationException("Repository owner is null");
        var repoName = repository.Name ?? throw new InvalidOperationException("Repository name is null");
        var defaultBranch = repository.DefaultBranch ?? throw new InvalidOperationException("Repository default branch is null");

        var existingPullRequestsByBot = (await _versionControl.GetPullRequests(
                server.EndPoint,
                ownerLogin,
                repoName,
                $"{server.UserName}:{branchName}",
                server.Token))
            .Where(p => string.Equals(p.User?.Login, server.UserName, StringComparison.OrdinalIgnoreCase));

        if (existingPullRequestsByBot.All(p => p.State != "open"))
        {
            _logger.LogInformation("Creating pull request for issue #{IssueId}...", issue.Iid);

            var title = $"Fix for issue #{issue.Iid}: {issue.Title}";
            var body = $@"
Automatically generated by Gemini Bot to fix issue #{issue.Iid}.

Closes #{issue.Iid}

## Issue
{issue.Title}

{issue.Description ?? "No description provided."}

## Changes
This pull request contains automated fixes generated by the Gemini Bot.

Please review carefully before merging.";

            await _versionControl.CreatePullRequest(
                server.EndPoint,
                ownerLogin,
                repoName,
                $"{server.UserName}:{branchName}",
                defaultBranch,
                title,
                body,
                server.Token);

            if (server.Provider == "GitLab")
            {
                await AssignBotToGitLabMr(server, issue, branchName);
            }
        }
    }

    private async Task AssignBotToGitLabMr(Server server, Issue issue, string branchName)
    {
        try
        {
            var userUrl = $"{server.EndPoint.TrimEnd('/')}/api/v4/user";
            var user = await _httpWrapper.SendHttpAndGetJson<GitLabUser>(userUrl, HttpMethod.Get, server.Token);
            
            var mrUrl = $"{server.EndPoint.TrimEnd('/')}/api/v4/projects/{issue.ProjectId}/merge_requests?state=opened&source_branch={branchName}";
            var mrs = await _httpWrapper.SendHttpAndGetJson<List<GitLabMergeRequestDto>>(mrUrl, HttpMethod.Get, server.Token);
            var mr = mrs.FirstOrDefault();

            if (mr != null)
            {
                 var updateUrl = $"{server.EndPoint.TrimEnd('/')}/api/v4/projects/{issue.ProjectId}/merge_requests/{mr.Iid}?assignee_id={user.Id}";
                 await _httpWrapper.SendHttpAndGetJson<object>(updateUrl, HttpMethod.Put, server.Token);
                 _logger.LogInformation("Assigned MR #{IID} to bot user {UserName}", mr.Iid, server.UserName);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to assign MR to bot for issue #{IssueId}", issue.Iid);
        }
    }
}
