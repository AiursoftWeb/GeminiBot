using Aiursoft.GitRunner;
using Aiursoft.GitRunner.Models;
using Aiursoft.GeminiBot.Configuration;
using Aiursoft.GeminiBot.Models;
using Aiursoft.NugetNinja.GitServerBase.Models;
using Aiursoft.NugetNinja.GitServerBase.Services;
using Aiursoft.NugetNinja.GitServerBase.Services.Providers;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Text.Json.Serialization;

namespace Aiursoft.GeminiBot.Services;

/// <summary>
/// Encapsulates the business logic for processing GitLab issues.
/// Provides a clean, testable interface for issue resolution workflow.
/// </summary>
public class IssueProcessor
{
    private readonly IVersionControlService _versionControl;
    private readonly WorkspaceManager _workspaceManager;
    private readonly GeminiCliService _geminiCliService;
    private readonly HttpWrapper _httpWrapper;
    private readonly LocalizationService _localizationService;
    private readonly GeminiBotOptions _options;
    private readonly ILogger<IssueProcessor> _logger;

    public IssueProcessor(
        IVersionControlService versionControl,
        WorkspaceManager workspaceManager,
        GeminiCliService geminiCliService,
        HttpWrapper httpWrapper,
        LocalizationService localizationService,
        IOptions<GeminiBotOptions> options,
        ILogger<IssueProcessor> logger)
    {
        _versionControl = versionControl;
        _workspaceManager = workspaceManager;
        _geminiCliService = geminiCliService;
        _httpWrapper = httpWrapper;
        _localizationService = localizationService;
        _options = options.Value;
        _logger = logger;
    }

    /// <summary>
    /// Processes an issue: validates, checks for existing PRs, clones repo, runs Gemini, and creates PR.
    /// </summary>
    public async Task<ProcessResult> ProcessAsync(Issue issue, Server server)
    {
        try
        {
            // Validation
            ValidateIssue(issue);

            // Check if issue already has an open PR/MR - using polymorphic interface method
            if (await _versionControl.HasOpenPullRequestForIssue(server.EndPoint, issue.ProjectId, issue.Iid, server.Token))
            {
                _logger.LogInformation("Issue #{IssueId} already has an open PR/MR. Skipping...", issue.Iid);
                return ProcessResult.Skipped("Issue already has an open PR/MR");
            }

            // Get repository details through interface - no GitLab-specific code!
            _logger.LogInformation("Fetching repository details for issue #{IssueId}...", issue.Iid);
            var repository = await _versionControl.GetRepository(server.EndPoint, issue.ProjectId.ToString(), string.Empty, server.Token);

            // Clone repository
            var workPath = GetWorkspacePath(issue, repository);
            _logger.LogInformation("Cloning repository for issue #{IssueId} to {WorkPath}...", issue.Iid, workPath);

            await _workspaceManager.ResetRepo(
                workPath,
                repository.DefaultBranch ?? throw new InvalidOperationException($"Repository default branch is null for issue {issue.Id}"),
                repository.CloneUrl ?? throw new InvalidOperationException($"Repository clone URL is null for issue {issue.Id}"),
                CloneMode.Full,
                $"{server.UserName}:{server.Token}");

            // Set user config right after reset so Gemini can commit if needed
            await _workspaceManager.SetUserConfig(workPath, server.DisplayName, server.UserEmail);

            // Run Gemini CLI
            var taskDescription = BuildTaskDescription(issue);
            _logger.LogInformation("Invoking Gemini CLI to process issue #{IssueId}...", issue.Iid);

            var geminiSuccess = await _geminiCliService.InvokeGeminiCliAsync(workPath, taskDescription, hideGitFolder: true);
            if (!geminiSuccess)
            {
                return ProcessResult.Failed($"Gemini CLI failed to process issue #{issue.Iid}");
            }

            // Gemini CLI may take a while to finish.
            await Task.Delay(1000);

            // Run localization if enabled
            _logger.LogInformation("Checking for localization requirements...");
            await _localizationService.LocalizeProjectAsync(workPath);

            // Check for changes
            if (!await _workspaceManager.PendingCommit(workPath))
            {
                _logger.LogInformation("Issue #{IssueId} - Gemini made no changes. Skipping...", issue.Iid);
                return ProcessResult.Skipped("No changes made");
            }

            // Commit changes
            _logger.LogInformation("Issue #{IssueId} has pending changes. Creating PR...", issue.Iid);

            var commitMessage = $"Fix for issue #{issue.Iid}: {issue.Title}\n\nAutomatically generated by Gemini Bot.";
            var branchName = $"fix-issue-{issue.Iid}";

            var saved = await _workspaceManager.CommitToBranch(workPath, commitMessage, branchName);
            if (!saved)
            {
                return ProcessResult.Failed($"Failed to commit changes for issue #{issue.Iid}");
            }

            // Fork if needed and push
            await EnsureRepositoryForkedAsync(server, repository);

            var pushPath = _versionControl.GetPushPath(server, repository);
            await _workspaceManager.Push(workPath, branchName, pushPath, force: true);

            // Create PR if needed
            await CreatePullRequestIfNeededAsync(server, repository, issue, branchName);

            return ProcessResult.Succeeded($"Successfully processed issue #{issue.Iid}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing issue #{IssueId}", issue.Iid);
            return ProcessResult.Failed($"Error processing issue #{issue.Iid}", ex);
        }
    }

    private void ValidateIssue(Issue issue)
    {
        if (string.IsNullOrWhiteSpace(issue.Title))
        {
            throw new ArgumentException($"Issue {issue.Id} has no title", nameof(issue));
        }

        if (issue.ProjectId <= 0)
        {
            throw new ArgumentException($"Issue {issue.Id} has invalid project ID", nameof(issue));
        }
    }

    private string GetWorkspacePath(Issue issue, Repository repository)
    {
        var repoName = repository.Name ?? "unknown";
        return Path.Combine(_options.WorkspaceFolder, $"{issue.ProjectId}-{repoName}-issue-{issue.Iid}");
    }

    private string BuildTaskDescription(Issue issue)
    {
        return $"Issue #{issue.Iid}: {issue.Title}\n\n{issue.Description ?? "No description provided."}\n\nPlease analyze this issue and make the necessary code changes to resolve it.\n\nDon't forget to bump the version for updated nuget package projects after necessary changes, while do NOT add a version tag for projects doesn't publish nuget packages!";
    }



    private async Task EnsureRepositoryForkedAsync(Server server, Repository repository)
    {
        var ownerLogin = repository.Owner?.Login ?? throw new InvalidOperationException("Repository owner is null");
        var repoName = repository.Name ?? throw new InvalidOperationException("Repository name is null");

        if (!await _versionControl.RepoExists(server.EndPoint, server.UserName, repoName, server.Token))
        {
            _logger.LogInformation("Forking repository {Org}/{Repo}...", ownerLogin, repoName);
            await _versionControl.ForkRepo(server.EndPoint, ownerLogin, repoName, server.Token);

            // Wait for fork to complete
            await Task.Delay(_options.ForkWaitDelayMs);

            while (!await _versionControl.RepoExists(server.EndPoint, server.UserName, repoName, server.Token))
            {
                _logger.LogInformation("Waiting for fork to complete...");
                await Task.Delay(_options.ForkWaitDelayMs);
            }
        }
    }

    private async Task CreatePullRequestIfNeededAsync(Server server, Repository repository, Issue issue, string branchName)
    {
        var ownerLogin = repository.Owner?.Login ?? throw new InvalidOperationException("Repository owner is null");
        var repoName = repository.Name ?? throw new InvalidOperationException("Repository name is null");
        var defaultBranch = repository.DefaultBranch ?? throw new InvalidOperationException("Repository default branch is null");

        var existingPullRequestsByBot = (await _versionControl.GetPullRequests(
                server.EndPoint,
                ownerLogin,
                repoName,
                $"{server.UserName}:{branchName}",
                server.Token))
            .Where(p => string.Equals(p.User?.Login, server.UserName, StringComparison.OrdinalIgnoreCase));

        if (existingPullRequestsByBot.All(p => p.State != "open"))
        {
            _logger.LogInformation("Creating pull request for issue #{IssueId}...", issue.Iid);

            var title = $"Fix for issue #{issue.Iid}: {issue.Title}";
            var body = $@"
Automatically generated by Gemini Bot to fix issue #{issue.Iid}.

Closes #{issue.Iid}

## Issue
{issue.Title}

{issue.Description ?? "No description provided."}

## Changes
This pull request contains automated fixes generated by the Gemini Bot.

Please review carefully before merging.";

            await _versionControl.CreatePullRequest(
                server.EndPoint,
                ownerLogin,
                repoName,
                $"{server.UserName}:{branchName}",
                defaultBranch,
                title,
                body,
                server.Token);

            if (server.Provider == "GitLab")
            {
                try
                {
                    // 1. Get Bot User ID
                    var userUrl = $"{server.EndPoint.TrimEnd('/')}/api/v4/user";
                    var user = await _httpWrapper.SendHttpAndGetJson<GitLabUser>(userUrl, HttpMethod.Get, server.Token);
                    
                    // 2. Find the MR we just created
                    var mrUrl = $"{server.EndPoint.TrimEnd('/')}/api/v4/projects/{issue.ProjectId}/merge_requests?state=opened&source_branch={branchName}";
                    var mrs = await _httpWrapper.SendHttpAndGetJson<List<GitLabMergeRequest>>(mrUrl, HttpMethod.Get, server.Token);
                    var mr = mrs.FirstOrDefault();

                    if (mr != null)
                    {
                         // 3. Assign to Bot
                         var updateUrl = $"{server.EndPoint.TrimEnd('/')}/api/v4/projects/{issue.ProjectId}/merge_requests/{mr.Iid}?assignee_id={user.Id}";
                         await _httpWrapper.SendHttpAndGetJson<object>(updateUrl, HttpMethod.Put, server.Token);
                         _logger.LogInformation("Assigned MR #{IID} to bot user {UserName}", mr.Iid, server.UserName);
                    }
                    else
                    {
                        _logger.LogWarning("Could not find created MR for issue #{IssueId} with branch {BranchName}", issue.Iid, branchName);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to assign MR to bot for issue #{IssueId}", issue.Iid);
                }
            }
        }
        else
        {
            _logger.LogInformation("Skipped creating new pull request for issue #{IssueId} because one already exists", issue.Iid);
        }
    }

    private class GitLabUser
    {
        [JsonPropertyName("id")]
        public int Id { get; set; }
    }

    private class GitLabMergeRequest
    {
        [JsonPropertyName("iid")]
        public int Iid { get; set; }
    }
}
